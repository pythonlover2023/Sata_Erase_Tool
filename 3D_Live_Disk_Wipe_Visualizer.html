<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî• IrsanAI 3D Live Disk Wipe Visualizer - Ultimate Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: #000; color: #0f0; overflow: hidden; }
        #canvas-container { width: 100vw; height: 100vh; position: relative; }
        #render-canvas { width: 100%; height: 100%; display: block; }
        .hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* --- LEFT SIDE PANEL (Stats) --- */
        .stats-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px; /* Increased width */
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #0f0;
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid rgba(0, 255, 0, 0.3);
            padding-bottom: 10px;
        }
        
        .stat-item:last-child { border-bottom: none; }

        .stat-label {
            font-size: 11px;
            color: #0f0;
            opacity: 0.8;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
        }

        .stat-icon { margin-right: 8px; font-size: 14px; }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
            padding-left: 22px; /* Align with text */
        }

        /* Progress Bar inside Stats Panel */
        .progress-container {
            margin-top: 10px;
            height: 25px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }
        .progress-bar { height: 100%; background: linear-gradient(90deg, #0f0, #0ff); width: 0%; transition: width 0.2s linear; box-shadow: 0 0 15px rgba(0, 255, 0, 0.6); }
        .progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: bold; font-size: 12px; text-shadow: 0 0 3px #000; color: #fff; }
        
        /* --- RIGHT SIDE ELEMENTS --- */

        /* Legend */
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 250px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #0f0;
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }
        .legend-title { font-size: 14px; margin-bottom: 10px; color: #0ff; border-bottom: 1px solid #0ff; padding-bottom: 5px; }
        .legend-item { display: flex; align-items: center; margin: 8px 0; font-size: 12px; }
        .legend-color { width: 15px; height: 15px; margin-right: 10px; border-radius: 3px; border: 1px solid #fff; }

        /* PiP Head-Cam (Moved below Legend) */
        #pip-container {
            position: absolute;
            top: 200px; /* Positioned below legend */
            right: 20px;
            width: 250px;
            height: 150px;
            border: 2px solid #0ff;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px);
            z-index: 20;
        }
        #pip-canvas { width: 100%; height: 100%; }
        #pip-label { position: absolute; top: 5px; left: 10px; color: #0ff; font-size: 10px; background: rgba(0,0,0,0.7); padding: 2px 5px; border-radius: 3px; }

        /* Live I/O Graph (Moved below PiP) */
        #io-graph-container {
            position: absolute;
            top: 370px; /* Positioned below PiP */
            right: 20px;
            width: 250px;
            background: rgba(0,0,0,0.85);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 10px;
        }
        #io-graph-label { font-size: 12px; text-align: center; margin-bottom: 5px; color: #0f0; }
        #io-graph { background: rgba(0, 20, 0, 0.3); width: 100%; height: 80px; display: block; }

        /* --- BOTTOM ELEMENTS --- */

        /* Sector Info Panel */
        .sector-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #ff0;
            border-radius: 10px;
            padding: 15px;
            min-width: 320px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(255, 255, 0, 0.2);
        }
        .sector-title { color: #ff0; font-size: 14px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 2px; border-bottom: 1px solid #ff0; padding-bottom: 5px; }
        .sector-info { font-size: 12px; line-height: 1.6; }
        
        /* Matrix Hex-Dump */
        #hex-dump {
            position: absolute;
            bottom: 160px; /* Above sector panel */
            left: 20px;
            width: 320px;
            height: 150px;
            font-size: 10px;
            line-height: 1.2;
            color: #0f0;
            opacity: 0.7;
            overflow: hidden;
            text-shadow: 0 0 5px #0f0;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-left: 2px solid #0f0;
        }

        /* Controls */
        .controls { position: absolute; bottom: 20px; right: 20px; pointer-events: all; }
        .control-btn { background: rgba(0, 255, 0, 0.2); border: 2px solid #0f0; color: #0f0; padding: 10px 20px; margin: 5px; border-radius: 5px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 12px; transition: all 0.3s; backdrop-filter: blur(10px); }
        .control-btn:hover { background: rgba(0, 255, 0, 0.4); box-shadow: 0 0 20px rgba(0, 255, 0, 0.6); transform: scale(1.05); }
        .control-btn.active { background: rgba(0, 255, 0, 0.6); box-shadow: 0 0 30px rgba(0, 255, 0, 0.8); }

    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="render-canvas"></canvas>
        
        <div class="hud">
            <!-- LEFT PANEL: Stats -->
            <div class="stats-bar" id="stats-bar">
                <div class="stat-item">
                    <div class="stat-label"><span class="stat-icon">üíæ</span>DISK MODEL</div>
                    <div class="stat-value" id="disk-model">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label"><span class="stat-icon">üì¶</span>CAPACITY</div>
                    <div class="stat-value" id="disk-capacity">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label"><span class="stat-icon">üßπ</span>SECTORS WIPED</div>
                    <div class="stat-value" id="sectors-wiped">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label"><span class="stat-icon">‚ö°</span>LIVE SPEED</div>
                    <div class="stat-value" id="wipe-speed">0 MB/s</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label"><span class="stat-icon">‚è±Ô∏è</span>TIME ELAPSED</div>
                    <div class="stat-value" id="time-elapsed">00:00</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label"><span class="stat-icon">‚è≥</span>ETA</div>
                    <div class="stat-value" id="eta">--:--</div>
                </div>

                <div class="progress-container">
                    <div class="progress-bar" id="progress-bar"></div>
                    <div class="progress-text" id="progress-text">0.00%</div>
                </div>
            </div>
            
            <!-- RIGHT SIDE -->

            <!-- 1. Legend -->
            <div class="legend">
                <div class="legend-title">üìä SECTOR STATUS</div>
                <div class="legend-item"><div class="legend-color" style="background: #333;"></div><span>Pending (Untouched)</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #ff0;"></div><span>In Progress (Active)</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #f00;"></div><span>Wiping (Writing)</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #0f0;"></div><span>Complete (Verified)</span></div>
            </div>
            
            <!-- 2. PiP Head-Cam -->
            <div id="pip-container">
                <div id="pip-label">üé• HEAD-CAM [LIVE]</div>
                <canvas id="pip-canvas"></canvas>
            </div>

            <!-- 3. Live I/O Graph -->
            <div id="io-graph-container">
                <div id="io-graph-label">üìà LIVE I/O (MB/s)</div>
                <canvas id="io-graph" width="230" height="80"></canvas>
            </div>

            <!-- BOTTOM LEFT -->

            <!-- Hex-Dump -->
            <div id="hex-dump"></div>

            <!-- Sector Info Panel -->
            <div class="sector-panel" id="sector-panel" style="display: none;">
                <div class="sector-title">üéØ CURRENT OPERATION</div>
                <div class="sector-info" id="sector-info">
                    <div>Sector: <span id="current-sector">-</span></div>
                    <div>Track: <span id="current-track">-</span></div>
                    <div>Pattern: <span id="wipe-pattern">-</span></div>
                    <div id="operation-detail" style="margin-top: 5px; color: #ff0; font-weight: bold;">-</div>
                </div>
            </div>
            
            <!-- Controls -->
            <div class="controls">
                <button class="control-btn active" id="btn-autofocus">üì∑ AUTO FOCUS</button>
                <button class="control-btn" id="btn-freecam">üéÆ FREE CAM</button>
                <button class="control-btn" id="btn-fullscreen">‚õ∂ FULLSCREEN</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ===== 3D VISUALIZATION ENGINE - ULTIMATE EDITION =====
        
        let scene, camera, renderer, disk, particles, clock;
        let pipRenderer, pipCamera;
        let autoFocus = true;
        let isSimulating = false;

        let totalSectors = 1, wipedSectors = 0, wipeSpeed = 0;
        let currentSectorIndex = 0;
        let sectorMeshes = [];
        let head, arm;

        // Graph and Hex-Dump
        const graphCanvas = document.getElementById('io-graph');
        const graphCtx = graphCanvas.getContext('2d');
        const speedHistory = new Array(60).fill(0); // 60 data points
        const hexDumpEl = document.getElementById('hex-dump');

        function init() {
            // Scene & Main Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.03);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Main Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('render-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // PiP Renderer & Camera
            const pipCanvas = document.getElementById('pip-canvas');
            pipRenderer = new THREE.WebGLRenderer({ canvas: pipCanvas, antialias: true });
            pipRenderer.setSize(pipCanvas.clientWidth, pipCanvas.clientHeight);
            pipCamera = new THREE.PerspectiveCamera(60, pipCanvas.clientWidth / pipCanvas.clientHeight, 0.1, 50);
            scene.add(pipCamera);

            // Lighting
            scene.add(new THREE.AmbientLight(0x404040, 0.8));
            const dirLight = new THREE.DirectionalLight(0x00ff88, 0.8);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // Create HDD Model
            createHDD();

            // Event Listeners & Clock
            clock = new THREE.Clock();
            window.addEventListener('resize', onWindowResize);
            document.getElementById('btn-autofocus').addEventListener('click', () => autoFocus = true);
            document.getElementById('btn-freecam').addEventListener('click', () => autoFocus = false);
            document.getElementById('btn-fullscreen').addEventListener('click', () => document.documentElement.requestFullscreen());

            animate();
        }
        
        function createHDD() {
            disk = new THREE.Group();
            // Platter
            const platterMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.2 });
            const platter = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 0.1, 64), platterMat);
            platter.rotation.x = Math.PI / 2;
            disk.add(platter);

            // Sectors
            const rings = 15, sectorsPerRing = 48;
            const sectorGeom = new THREE.BoxGeometry(0.1, 0.05, 0.1);
            for (let r = 0; r < rings; r++) {
                const radius = 0.8 + (r / rings) * 1.6;
                for (let s = 0; s < sectorsPerRing; s++) {
                    const angle = (s / sectorsPerRing) * Math.PI * 2;
                    const sector = new THREE.Mesh(sectorGeom, new THREE.MeshBasicMaterial({ color: 0x333333 }));
                    sector.position.set(Math.cos(angle) * radius, 0.06, Math.sin(angle) * radius);
                    sector.userData.status = 'pending';
                    sectorMeshes.push(sector);
                    disk.add(sector);
                }
            }

            // Arm and Head
            const headGroup = new THREE.Group();
            arm = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 0.2), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
            arm.position.x = 1.25;
            head = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.2), new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xcc0000 }));
            head.position.set(2.5, 0.05, 0);
            headGroup.add(arm, head);
            headGroup.position.set(-2.5, 0.1, 0);
            disk.add(headGroup);

            // Attach PiP camera to the head
            pipCamera.position.set(0, 0.3, 0);
            pipCamera.rotation.x = -Math.PI / 2.5;
            head.add(pipCamera);

            scene.add(disk);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();

            // Animate disk based on live speed
            const rotationSpeed = isSimulating ? THREE.MathUtils.lerp(0.5, 5, Math.min(wipeSpeed / 150, 1)) : 0;
            disk.rotation.y += delta * rotationSpeed;

            // Animate head position
            if (isSimulating && arm) {
                const progress = wipedSectors / totalSectors;
                const armAngle = (progress * 15) % 1 > 0.5 ? 0.4 : -0.4;
                arm.parent.rotation.y = THREE.MathUtils.lerp(arm.parent.rotation.y, armAngle, delta * 2);
                const armRadius = 1.2 + (progress * 1.3) % 1.3;
                arm.position.x = armRadius;
                head.position.x = armRadius * 2;
            }

            // Main camera logic
            if (autoFocus && isSimulating) {
                const focusPoint = head.getWorldPosition(new THREE.Vector3());
                camera.position.lerp(new THREE.Vector3(focusPoint.x + 2, focusPoint.y + 2, focusPoint.z + 2), delta * 1);
                camera.lookAt(focusPoint);
            }

            // Update immersion elements
            if (isSimulating) {
                updateHexDump();
                drawGraph();
            }
            
            renderer.render(scene, camera);
            pipRenderer.render(scene, pipCamera);
        }

        function updateVisualsFromLiveData() {
            const progress = totalSectors > 0 ? wipedSectors / totalSectors : 0;
            const targetSectorIndex = Math.floor(progress * sectorMeshes.length);
            
            for (let i = currentSectorIndex; i < targetSectorIndex && i < sectorMeshes.length; i++) {
                const sector = sectorMeshes[i];
                if (sector.userData.status === 'pending') {
                    sector.userData.status = 'wiping';
                    sector.material.color.setHex(0xff0000);
                    setTimeout(() => {
                        sector.userData.status = 'complete';
                        sector.material.color.setHex(0x00ff00);
                    }, 300);
                }
            }
            currentSectorIndex = targetSectorIndex;
        }

        // --- Immersion Functions ---
        function updateHexDump() {
            let dump = '';
            for (let i = 0; i < 12; i++) {
                dump += (Math.random().toString(16).substring(2, 10) + ' ').toUpperCase() + '\n';
            }
            hexDumpEl.textContent = dump;
        }

        function drawGraph() {
            speedHistory.push(wipeSpeed);
            if (speedHistory.length > 60) speedHistory.shift();

            const w = graphCanvas.width;
            const h = graphCanvas.height;
            graphCtx.clearRect(0, 0, w, h);

            // Draw Grid
            graphCtx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
            graphCtx.lineWidth = 1;
            graphCtx.beginPath();
            for (let y = 0; y < h; y += 20) {
                graphCtx.moveTo(0, y);
                graphCtx.lineTo(w, y);
            }
            graphCtx.stroke();

            // Dynamic Scaling
            const maxVal = Math.max(50, ...speedHistory) * 1.2; // Min scale 50 MB/s, 20% headroom

            // Draw Line
            graphCtx.beginPath();
            graphCtx.strokeStyle = '#0f0';
            graphCtx.lineWidth = 2;
            graphCtx.shadowBlur = 5;
            graphCtx.shadowColor = '#0f0';

            for (let i = 0; i < speedHistory.length; i++) {
                const x = (i / (speedHistory.length - 1)) * w;
                const y = h - (speedHistory[i] / maxVal) * h;
                if (i === 0) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();
            graphCtx.shadowBlur = 0;

            // Draw Max Value Text
            graphCtx.fillStyle = '#0f0';
            graphCtx.font = '10px Courier New';
            graphCtx.fillText(Math.round(maxVal) + ' MB/s', 5, 10);
        }
        
        // ===== LIVE DATA INTEGRATION =====
        let lastStatus = "";
        function fetchLiveData() {
            fetch('live_wipe_status.json?' + Date.now())
                .then(response => response.json())
                .then(data => {
                    if (!data || !data.wipe) return;

                    totalSectors = data.wipe.total_sectors || 1;
                    wipedSectors = data.wipe.wiped_sectors;
                    wipeSpeed = data.wipe.speed_mbps;

                    if (document.getElementById('disk-model').textContent !== data.disk.model) {
                        document.getElementById('disk-model').textContent = data.disk.model;
                        document.getElementById('disk-capacity').textContent = data.disk.capacity_gb + ' GB';
                    }

                    if (data.current_operation) {
                        document.getElementById('current-sector').textContent = data.current_operation.sector.toLocaleString();
                        document.getElementById('current-track').textContent = data.current_operation.track;
                        document.getElementById('wipe-pattern').textContent = data.current_operation.pattern;
                        document.getElementById('operation-detail').textContent = data.current_operation.operation;
                    }

                    const elapsed = Math.round(data.wipe.elapsed_seconds);
                    document.getElementById('time-elapsed').textContent = `${String(Math.floor(elapsed / 60)).padStart(2, '0')}:${String(elapsed % 60).padStart(2, '0')}`;

                    const eta = Math.round(data.wipe.eta_seconds);
                    document.getElementById('eta').textContent = (eta >= 0) ? `${String(Math.floor(eta / 60)).padStart(2, '0')}:${String(eta % 60).padStart(2, '0')}` : '--:--';

                    const progress = totalSectors > 0 ? (wipedSectors / totalSectors) * 100 : 0;
                    document.getElementById('progress-bar').style.width = progress + '%';
                    document.getElementById('progress-text').textContent = progress.toFixed(2) + '%';
                    document.getElementById('sectors-wiped').textContent = Math.floor(wipedSectors).toLocaleString();
                    document.getElementById('wipe-speed').textContent = wipeSpeed.toFixed(1) + ' MB/s';

                    updateVisualsFromLiveData();

                    if (data.wipe.status === 'wiping' && lastStatus !== 'wiping') isSimulating = true;
                    if (data.wipe.status === 'complete' || data.wipe.status === 'failed') {
                        isSimulating = false;
                        if (data.wipe.status === 'complete') {
                            document.getElementById('progress-bar').style.width = '100%';
                            document.getElementById('progress-text').textContent = '100.00%';
                        }
                    }
                    lastStatus = data.wipe.status;
                })
                .catch(err => console.log('Live data fetch failed.'));
        }
        
        setInterval(fetchLiveData, 200);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            const pipCanvas = document.getElementById('pip-canvas');
            pipRenderer.setSize(pipCanvas.clientWidth, pipCanvas.clientHeight);
            pipCamera.aspect = pipCanvas.clientWidth / pipCanvas.clientHeight;
            pipCamera.updateProjectionMatrix();
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>